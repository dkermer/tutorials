Working with Non-English Languages

#### Normalization

A **[diacritic]((https://en.wikipedia.org/wiki/Diacritic) )** or **diacritical mark** is an accent or other sign added above or below a **base character** to change it's pronunciation:  e +  ́ = é . In Unicode, these can be represented as a single character (*composed*) or as multiple characters (*decomposed*). Further, the Unicode system groups characters by language and not-infrequently gives different codes to [seemingly-identical characters](https://en.wikipedia.org/wiki/Duplicate_characters_in_Unicode). 

Unicode makes the important distinction between characters that are **canonically equivalent** (look the same) and **compatible** (mean the same). The standard includes [normalization charts](http://www.unicode.org/charts/normalization/) for each language. Most statistical software has a function to utilize this: Stata has [ustrnormalize](https://www.stata.com/manuals/m-5ustrnormalize.pdf), SPSS has [NORMALIZE](https://www.ibm.com/support/knowledgecenter/SSLVMB_23.0.0/spss/base/syn_transformation_expressions_string_functions.html), R has the [stringi](https://cran.r-project.org/web/packages/stringi/index.html) package, and Python has the [Unicodedata](https://docs.python.org/3/library/unicodedata.html) package.  

#### Simplification

To further standardize text, some may wish to remove accents, or use other methods of [romanization](https://en.wikipedia.org/wiki/Romanization) (using only Latin characters). Importantly, these techniques can [remove important differences between words](https://www.w3.org/International/wiki/Case_folding). General translation or replacement functions can accomplish this by specifying your own list of replacements. However, others have created tools to do this for most languages. 

**Removing accents** and reducing all characters to their base (á to a) is very common. Indeed, [people often assume](https://alistapart.com/article/accent-folding-for-auto-complete/) that searching for *resume* will give results that include *résumé*.  To do this, convert from Unicode encoding to ASCII encoding or using string substitution with regular expressions as illustrated in [this post using Stata](https://www.statalist.org/forums/forum/general-stata-discussion/general/1487336-remove-accents-on-a-string-variable-in-stata). SAS also has a [BASECHAR](https://documentation.sas.com/?docsetId=nlsref&docsetTarget=p078j5y1bbc9xfn1scp11kw3nmnt.htm&docsetVersion=9.4&locale=en) function

**Romanization**, which includes **[transliteration](https://en.wikipedia.org/wiki/Transliteration)**, means to represent the approximate sound of characters using the Roman alphabet (i.e., Latin). For example, Beijing is a particular [Pinyin](https://en.wikipedia.org/wiki/Pinyin) transliteration of the Chinese characters 北京. R has the [stringi](https://cran.r-project.org/web/packages/stringi/index.html), [pinyin](https://cran.r-project.org/web/packages/pinyin/index.html), and [UnidecodeR](https://www.rdocumentation.org/packages/UnidecodeR/versions/0.02) packages, Python has the [polyglot](https://pypi.org/project/polyglot/) and [Unidecode](https://pypi.org/project/Unidecode/) packages, but you can also [create your own transformation](https://programminghistorian.org/en/lessons/transliterating). 